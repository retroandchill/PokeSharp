using System.Runtime.Serialization;
using System.Collections.Immutable;
using PokeSharp.Abstractions;
using PokeSharp.Compiler.Core.Serialization;

namespace {{Namespace}};

{{DeclaredAccessiblity}}partial {{ObjectType}} {{ClassName}} : IPbsDataModel<{{ClassName}}>
{
    public static string BasePath => "{{FilePath}}";
    public static bool IsOptional => {{IsOptionalString}};

    public static {{ClassName}} ParsePbsData(PbsSection section, Func<string, {{ClassName}}> modelFactory = null)
    {
        {{#Properties}}
        {{#IsSectionName}}
        var prop_{{Name}} = Parse_{{Name}}({{#NeedsSectionName}}section.SectionName, {{/NeedsSectionName}}section.SectionName);
        {{/IsSectionName}}
        {{^IsSectionName}}
        {{#AppearsOnce}}
        var found_{{Name}} = false;
        {{Type}} prop_{{Name}} = default;
        {{/AppearsOnce}}
        {{^AppearsOnce}}
        var prop_{{Name}} = new {{ConcreteType}}();
        {{/AppearsOnce}}    
        {{/IsSectionName}}
    
        {{/Properties}}
        {{#SubSchemas}}
        var found_{{Name}} = false;
        {{#IsCollection}}
        var prop_{{Name}} = new List<(string SectionName, List<PbsKeyValueLine> Lines, FileLineData HeaderLine)>();    
        (string SectionName, List<PbsKeyValueLine> Lines, FileLineData HeaderLine)? prop_{{Name}}_current = null;
        {{/IsCollection}} 
        {{^IsCollection}}
        (string SectionName, List<PbsKeyValueLine> Lines, FileLineData HeaderLine)? prop_{{Name}} = null;    
        {{/IsCollection}}  
            
        {{/SubSchemas}}
        foreach (var (key, rawValue, lineData) in section.Lines)
        {
            try
            {
                switch (key)
                {
                    {{#Properties}}
                    {{^IsSectionName}}
                    case "{{KeyName}}":
                        {{#AppearsOnce}}
                        found_{{Name}} = true;
                        prop_{{Name}} = Parse_{{Name}}({{#NeedsSectionName}}section.SectionName, {{/NeedsSectionName}}rawValue);
                        {{/AppearsOnce}}
                        {{^AppearsOnce}}
                        prop_{{Name}}.Add(Parse_{{Name}}({{#NeedsSectionName}}section.SectionName, {{/NeedsSectionName}}rawValue));    
                        {{/AppearsOnce}}   
                        break;
                    {{/IsSectionName}}
                    {{/Properties}}
                    {{#SubSchemas}}
                    case "{{Name}}":
                        found_{{Name}} = true;
                        {{#IsCollection}}
                        if (prop_{{Name}}_current.HasValue)
                        {
                            prop_{{Name}}.Add(prop_{{Name}}_current.Value);
                        }
                        
                        {{/IsCollection}}
                        prop_{{Name}}{{#IsCollection}}_current{{/IsCollection}} = (rawValue, [], lineData);
                        break;
                    {{#Schema.Properties}}
                    {{^IsSectionName}}
                    case "{{KeyName}}":
                        if (!prop_{{../Name}}_current.HasValue)
                        {
                            throw new SerializationException("{{../Name}} hasn't been defined yet!");
                        }
                        
                        prop_{{../Name}}{{#if ../IsCollection}}_current{{/if}}.Value.Lines.Add(new PbsKeyValueLine(key, rawValue, lineData));
                        break;
                    {{/IsSectionName}}
                    {{/Schema.Properties}}
                    {{/SubSchemas}}
                }
            }
            catch (SerializationException ex)
            {
                throw new PbsParseException($"{ex.Message}\n{lineData.LineReport}", ex);
            }
        }
        {{#SubSchemas}}
        {{#IsCollection}}

        if (prop_{{Name}}_current{{#IsValueType}}.HasValue{{/IsValueType}}{{^IsValueType}} is not null{{/IsValueType}})
        {
            prop_{{Name}}.Add(prop_{{Name}}_current.Value);
        }            
        {{/IsCollection}}
        {{/SubSchemas}}
        {{#Properties}}
        {{^IsSectionName}}
        {{#IsRequired}}
        {{#AppearsOnce}}
        
        if (!found_{{Name}})
        {
            throw new PbsParseException($"Missing required property '{{Name}}'\n{lineData.LineReport}");
        }    
        {{/AppearsOnce}}
        {{/IsRequired}}
        {{/IsSectionName}}    
        {{/Properties}}
        
        {{ClassName}} result;
        if (modelFactory is not null) 
        {
            result = modelFactory(section.SectionName);
            {{#Properties}}
            {{#IsRequired}}
            {{^IsInitOnly}}
            result.{{Name}} = prop_{{Name}};
            {{/IsInitOnly}}
            {{/IsRequired}}
            {{/Properties}}
        }
        else
        {
            result = new {{ClassName}} 
            {
                {{#Properties}}
                {{#IsRequired}}
                {{Name}} = prop_{{Name}},
                {{/IsRequired}}
                {{/Properties}}
            };
        }
        {{#Properties}}
        {{^IsRequired}}
        {{#AppearsOnce}}
        
        if (found_{{Name}})
        {
            result.{{Name}} = prop_{{Name}};
        }    
        {{/AppearsOnce}}
        {{^AppearsOnce}}
            
        result.{{Name}} = prop_{{Name}};    
        {{/AppearsOnce}}    
        {{/IsRequired}}
        {{/Properties}}
        {{#SubSchemas}}
        {{#IsCollection}}
        
        if (found_{{Name}})
        {
            var outputList = new List<{{SchemaType}}>();
            foreach (var (sectionName, lines, fileLineData) in prop_{{Name}})
            {
                outputList.Add({{SchemaType}}.ParsePbsData(new PbsSection(sectionName, lines.ToImmutableArray(), fileLineData)));
            }
            result.{{Name}} =  outputList;
        }
        {{/IsCollection}}
        {{^IsCollection}}
        if (found_{{Name}} && prop_{{Name}}.HasValue)
        {
            var (sectionName, lines, fileLineData) = prop_{{Name}}.Value;
            result.{{Name}} = {{SchemaType}}.ParsePbsData(new PbsSection(sectionName, lines.ToImmutableArray(), fileLineData));
        } 
        {{/IsCollection}}    
        {{/SubSchemas}}

        return result;
    }
    {{#Properties}}
    
    private static {{ParsedType}} Parse_{{Name}}({{#NeedsSectionName}}string sectionName, {{/NeedsSectionName}}string value)
    {
        {{#IsSimpleType}}
        {{#TypeEntries}}
        {{#IsUnformatted}}
        return {{>ParseLogic Parameter='value'}};  
        {{/IsUnformatted}}
        {{^IsUnformatted}}
        var soleEntry = CsvParser.SplitCsvLine(value).Single();
        return {{>ParseLogic Parameter='soleEntry'}};  
        {{/IsUnformatted}}
        {{/TypeEntries}}
        {{/IsSimpleType}}
        {{^IsSimpleType}}
        {{#IsCollection}}
        var result = new {{ConcreteType}}();
        {{#IsFixedSize}}
        var splitLine = CsvParser.SplitCsvLine(value).ToImmutableArray(); 
        {{#WithIndent '        '}}
        {{>EvaluateComplexType ResultLineStart='result.Add(' ResultLineEnd=');'}}
        {{/WithIndent}}
        {{/IsFixedSize}}
        {{^IsFixedSize}}
        
        {{#NeedsSubsections}}
        foreach (var splitLine in CsvParser.SplitCsvLine(value).Chunk({{TypeEntries.Length}}).Select(b => b.ToImmutableArray()))
        {
            {{~#WithIndent '            '~}}
            {{>EvaluateComplexType ResultLineStart='result.Add(' ResultLineEnd=');' MultipleOf=true}}
            {{~/WithIndent~}}
        }
        {{/NeedsSubsections}}
        {{^NeedsSubsections}}
        foreach (var entry in CsvParser.SplitCsvLine(value))
        {
            result.Add({{>ParseLogic Parameter='entry'}});
        }
        {{/NeedsSubsections}}
              
        {{/IsFixedSize}}
        return result;  
        {{/IsCollection}}
        {{^IsCollection}}
        var splitLine = CsvParser.SplitCsvLine(value).ToImmutableArray();    
        {{#WithIndent '        '}}
        {{>EvaluateComplexType ResultLineStart='return ' ResultLineEnd=';'}}
        {{/WithIndent}}
        {{/IsCollection}}
        {{/IsSimpleType}}
    }
    {{/Properties}}

    public IEnumerable<string> WritePbsData()
    {
        {{#HasComparisonFactory}}
        var comparison = {{ComparisonFactory}}();
        {{/HasComparisonFactory}}
        {{#Properties}}
        {{#IsSectionName}}
        yield return $"[{Write_{{Name}}({{Name}})}]";    
        {{/IsSectionName}}
        {{/Properties}}
        {{#Properties}}
        {{^IsSectionName}}

        {{#if ../HasComparisonFactory}}
        if ({{#IsSequence}}!{{Name}}.SequenceEqual(comparison.{{Name}}){{/IsSequence}}{{^IsSequence}}{{Name}} != comparison.{{Name}}{{/IsSequence}})
        {
            {{#WithIndent '            '}}
            {{>PropertyWriteChecks}}    
            {{/WithIndent}}
        }
        {{/if}}
        {{^if ../HasComparisonFactory}}
        {{#WithIndent '        '}}
        {{>PropertyWriteChecks}}    
        {{/WithIndent}}
        {{/if}}
        {{/IsSectionName}}    
        {{/Properties}}
        {{#SubSchemas}}
        {{#IsCollection}}
        foreach (var item in {{Name}})
        {
            foreach (var (i, line) in item.WritePbsData().Index()) {
                if (i == 0)
                {
                    yield return $"{{Name}} = {line[1..^1]}";
                }
                else 
                {
                    yield return $"    {line}";
                }
            }
        }    
        {{/IsCollection}} 
        {{^IsCollection}}
        foreach (var (i, line) in {{Name}}.WritePbsData().Index()) {
            if (i == 0)
            {
                yield return $"{{Name}} = {line[1..^1]}";
            }
            else 
            {
                yield return $"    {line}";
            }
        }
        {{/IsCollection}}    
        {{/SubSchemas}}
    }
    {{#Properties}}
    
    {{#HasValidation}}
    {{#HasBuiltInValidation}}
    private {{#ValidateMethodIsStatic}}static {{/ValidateMethodIsStatic}}bool {{ValidateMethodName}}({{ParsedType}} value)
    {
        {{#HasCustomValidation}}if ({{CustomValidateMethod}}(value)) return true;{{/HasCustomValidation}}
        {{#IsCollection}}if (value.Count == 0) return false;{{/IsCollection}}
        return {{#IsBoolean}}value{{/IsBoolean}}{{^IsBoolean}}true{{/IsBoolean}};
    }
    
    {{/HasBuiltInValidation}}
    {{/HasValidation}}    
    private {{#CustomWriteMethodIsStatic}}static {{/CustomWriteMethodIsStatic}}string Write_{{Name}}({{ParsedType}} value)
    {
        {{#HasCustomWriteMethod}}
        return {{CustomWriteMethod}}(value);
        {{/HasCustomWriteMethod}}
        {{^HasCustomWriteMethod}}
        {{#IsSimpleType}}
        {{#TypeEntries}}
        return {{>WriteMethodCall Value='value'}};
        {{/TypeEntries}}
        {{/IsSimpleType}}
        {{^IsSimpleType}}
        {{#IsCollection}}
        {{#NeedsSubsections}}
        {{#IsFixedSize}}
        var output = new List<string>({{MaxLength}});
        {{#TypeEntries}}
        {{#IsOptional}}if (value.Count > {{Index}}) {{/IsOptional}}output.Add({{#Indexed}}{{>WriteMethodCall Value='value[{{Index}}]'}}{{/Indexed}});
        {{/TypeEntries}}
        return string.Join(',', output);    
        {{/IsFixedSize}}
        {{^IsFixedSize}} 
        return string.Join(',', value.SelectMany(IEnumerable<string> (x) =>
            {
                var ({{#TypeEntries}}item{{Index}}{{^IsLast}}, {{/IsLast}}{{/TypeEntries}}) = x;
                return [{{#TypeEntries}}{{#Indexed}}{{>WriteMethodCall Value='item{{Index}}'}}{{/Indexed}}{{^IsLast}}, {{/IsLast}}{{/TypeEntries}}];
            }));
        {{/IsFixedSize}}
        {{/NeedsSubsections}}
        {{^NeedsSubsections}}
        return string.Join(',', value.Select(x => {{>WriteMethodCall Value='x'}}));
        {{/NeedsSubsections}}
        {{/IsCollection}}
        {{^IsCollection}}
        var ({{#TypeEntries}}item{{Index}}{{^IsLast}}, {{/IsLast}}{{/TypeEntries}}) = value;
        var output = new List<string>({{MaxLength}});
        {{#TypeEntries}}
        {{#IsOptional}}if (item{{Index}} != {{DefaultValue}}) {{/IsOptional}}output.Add({{#Indexed}}{{>WriteMethodCall Value='item{{Index}}'}}{{/Indexed}});
        {{/TypeEntries}}
        return string.Join(',', output);
        {{/IsCollection}}
        {{/IsSimpleType}}
        {{/HasCustomWriteMethod}}
    }
    {{/Properties}}
}