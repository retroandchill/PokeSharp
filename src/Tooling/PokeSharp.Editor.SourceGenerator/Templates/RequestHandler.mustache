#nullable enable
using System.Collections.Immutable;
using System.Threading;
using PokeSharp.Core.Strings;
using PokeSharp.Core.Utils;
using PokeSharp.Editor.Core.PokeEdit.Requests;
using PokeSharp.Editor.Core.PokeEdit.Serialization;

namespace {{Namespace}};

partial class {{ClassName}} : IPokeEditController
{
    private static readonly Name ControllerName = "{{ControllerName}}";
    public Name Name => ControllerName;

    private ImmutableDictionary<Name, IRequestHandler> Handlers => LazyInitializer.EnsureInitialized(ref field, BuildHandlers);

    private ImmutableDictionary<Name, IRequestHandler> BuildHandlers()
    {
        var builder = ImmutableDictionary.CreateBuilder<Name, IRequestHandler>();
        {{#Methods}}
        builder.Add("{{Name}}", new {{../ClassName}}{{Name}}Handler(this));
        {{/Methods}}
        return builder.ToImmutable();
    }

    public IRequestHandler? GetRequestHandler(Name methodName)
    {
        return Handlers.GetValueOrDefault(methodName);
    }
}
{{#Methods}}
    
internal sealed class {{../ClassName}}{{Name}}Handler({{../ClassName}} owner) : IRequestHandler
{
    public void Process<TReader, TWriter>(ref TReader reader, ref TWriter writer, IPokeEditSerializer serializer) 
        where TReader : IRequestParameterReader, allows ref struct
        where TWriter : IResponseWriter, allows ref struct
    {
        {{#SupportsSync}}
        {{#Parameters}}
        var {{Name}} = reader.Read{{ReadType}}{{Generic}}({{#IsSerialized}}serializer{{/IsSerialized}}){{#NeedsNullCheck}}.RequireNonNull(){{/NeedsNullCheck}};
        {{/Parameters}}
        {{#HasResponse}}var response = {{/HasResponse}}owner.{{SyncName}}({{#Parameters}}{{SyncPassExpression}}{{^IsLast}}, {{/IsLast}}{{/Parameters}});
        {{#HasResponse}}
        writer.Write{{ResponseWriteType}}(response{{#NeedsNullCheck}}.RequireNonNull(){{/NeedsNullCheck}}{{#SerializedResponse}}, serializer{{/SerializedResponse}});
        {{/HasResponse}}
        {{/SupportsSync}}
        {{^SupportsSync}}
        throw new InvalidOperationException("Request {{Name}} on controller {{../ControllerName}} cannot be invoked synchronously");
        {{/SupportsSync}}
    }

    public async ValueTask ProcessAsync(IAsyncRequestParameterReader reader, IAsyncResponseWriter writer, IPokeEditSerializer serializer, CancellationToken cancellationToken = default)
    {
        {{#HasParameters}}
        cancellationToken.ThrowIfCancellationRequested();
        {{#Parameters}}
        var {{Name}} = await reader.Read{{ReadType}}Async{{Generic}}({{#IsSerialized}}serializer, {{/IsSerialized}}cancellationToken);
        {{/Parameters}}

        {{/HasParameters}}
        cancellationToken.ThrowIfCancellationRequested();
        {{#HasResponse}}var response = {{/HasResponse}}{{#IsAsync}}await {{/IsAsync}}owner.{{AsyncName}}({{#Parameters}}{{AsyncPassExpression}}{{^IsLast}}, {{/IsLast}}{{/Parameters}}{{#HasCancellationToken}}cancellationToken{{/HasCancellationToken}});
        {{#HasResponse}}

        cancellationToken.ThrowIfCancellationRequested();
        await writer.Write{{ResponseWriteType}}Async(response{{#NeedsNullCheck}}.RequireNonNull(){{/NeedsNullCheck}}, {{#SerializedResponse}}serializer, {{/SerializedResponse}}cancellationToken);
        {{/HasResponse}}
    }
}
{{/Methods}}